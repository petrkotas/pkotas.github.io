<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
    <title type="text" xml:lang="en">Petr Kotas</title>
    <link type="application/atom+xml" rel="self" href="kotas.tech/atom.xml"/>
  
  <link href="kotas.tech/"/>
  <id>kotas.tech/</id>
  <updated>2018-12-24T08:02:43Z</updated>
  <author>
    <name>Petr Kotas</name>
    <email>petr.kotas@gmail.com</email>
  </author>
  <rights type="text">Copyright © 2018 Petr Kotas. All rights reserved.</rights>
  
  <entry>
  <title type="text">oVirt: Starting the virtual machine</title>
  <link rel="alternate" type="text/html" href="kotas.tech/starting-virtual-machine.html" />
  <id>kotas.tech/starting-virtual-machine</id>
  <published>2017-11-11T00:00:00Z</published>
  <updated>2017-11-11T00:00:00Z</updated>
  <content type="html"><![CDATA[ <h1 id="ovirt-starting-the-virtualmachine">oVirt: Starting the virtual machine</h1>

<p>Starting up a virtual machine (VM) is not an easy task, there are lot of things going on hidden from the plain sight and studying it alone is a challenging task. The goal of this post is to simplify the process of learning how the oVirt hypervisor works. The concept of the oVirt is illustrated on the process of starting up the VM, which covers everything from top to the bottom.</p>

<p><strong>Disclaimer:</strong> I am an engineer working close to the host part of the oVirt, therefore my knowledge of the engine is limited.</p>

<p><img src="assets/images/ovirt/webadmin.png" alt="ovirt web admin" /></p>

<h2 id="architecture">Architecture</h2>

<p>Let me start with explaining the main parts oVirt hypervisor architecture. It will help a lot in understanding the overall process of the VM start up flow. Following is the simplified architecture, where I omit auxiliary components and support scripts. This will allow me to focus on the core concept without distractions.</p>

<p>The architecture comprises of three main components: 1) web UI and engine, 2) VDSM, 3) guest agent.</p>

<p>The web UI is where the user makes first contact with the oVirt hypervisor. The web UI is the main command center of the engine and allows user to control all aspects and states of the VMs.</p>

<p>The engine is the hypervisor brain that manages all VMs and all hosts. It also orchestrates the migration of VMs and control that highly available VMs are really highly available.</p>

<p>Of course, for the engine to be able to execute commands it needs a worker running on each host. In the oVirt this worker is named the VDSM and handles all the tasks linked with direct manipulation of the VMs and a preparation of host.</p>

<p>Last but not least, for the engine to know the health status of the running VMs it also needs the daemon running in each VM. This daemon is called the oVirt guest agent and thanks to its service the engine knows important information about each VM. This information is: VM IP, list of installed software, health, installed OS and up time.</p>

<h2 id="web-ui-andengine">Web UI and Engine</h2>

<p>The engine is the brain of the oVirt hypervisor, but what does it means, right? The engine does all the hard work of managing the VM. It knows the states, setups and current capacity of all hosts as well as the running states of all VMs. Therefore it can do the scheduling for the deployment of <a href="https://en.wikipedia.org/wiki/High_availability">highly available</a> VMs or decide on which host the VM will be started according to host capacity.</p>

<p>At this point, it is good time to tell you, that the engine is composed of three parts: 1) the web UI, 2) the Java backend and 3) the postgresql database. The web UI server as main command center for the whole oVirt and it is the entry point from where you start your VM. By pressing “VM run” button.</p>

<p><img src="assets/images/ovirt/ovirt-engine.png" alt="ovirt engine" /></p>

<p>Once the user presses the button, the Java backend starts to build the VM configuration. The process begins by accessing the Postgresql database. If the VM already exists, the list of its  devices, storage drives, current state (new, paused, hibernated) and guest agent version is retrieved. From the retrieved data, the backend build the VM configuration.</p>

<p>From the built configuration, the VDSM command for running the VM is created, which is sent to the host running VDSM via JSON RPC. The run command contains information about machine start-up, the guest agent version, devices setup and if the machine should start paused (used for accessing the boot manager). Once the command is built, it is sent to the VDSM for execution.</p>

<h2 id="host">Host</h2>

<p><img src="assets/images/ovirt/vdsm-libvirt-qemu.png" alt="VDSM and QEMU" /></p>

<p>Now, when the VDSM receives the command, it starts the work on running the VM. As you can see from the picture, before any VM can be run in the <a href="https://www.qemu.org">QEMU</a>, the VDSM needs to go through <a href="https://libvirt.org">libVirt</a> as its middle man. Furthermore, the VDSM needs to handle states of the VMs running on its host. While it might not seem like a big deal, things can get complicated really fast.</p>

<p>I will start with the high level overview. As I have already mentioned, the virtualization platform for the oVirt is the QEMU set up on <a href="https://www.linux-kvm.org">KVM</a>. Communication with QEMU is actually pretty complicated and it covers a lot of work related to handling networks and hardware devices. Good project does not reinvent the wheel where the wheel is already available, therefore VDSM manages QEMU through adapter called the libVirt. LibVirt nicely implements all the low level routines needed to operate QEMU, and allows VDSM to use high level commands like “create domain”, which creates Virtual Machine, obviously. Besides communication with libVirt, the VDSM has a small registry with all VMs running on its host, where it store current state and operation. VDSM also, communicates with the quest agent running inside the VM and passes the communication to the engine. Beside that it does quite a few other things, which I will cover in some next post.</p>

<p>So now we know what is the main purpose of the VDSM, but how it is all implemented and how it will lunch my VM?</p>

<p>Well first the VDSM need to create connection to the <a href="https://github.com/oVirt/vdsm/blob/1b5dfb9dec2a8de8577ac8a939120306df3d5565/lib/vdsm/libvirtconnection.py#L45">libVirt and start listening for its events</a>. This is done in separate thread, so it is non blocking and allows to pass control to the rest of application. The connection goes both ways, it can pass the commands to the libVirt and it actively listens for events on libVirt and <a href="https://github.com/oVirt/vdsm/blob/1b5dfb9dec2a8de8577ac8a939120306df3d5565/lib/vdsm/clientIF.py#L522">allows for reaction</a>.</p>

<p>To listen to the oVirt engine, the VDSM has to create a <a href="https://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> server, to which the engine sends its commands. The code doing exactly this resides in the <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/clientIF.py#L67">clientIF</a>, which is the VDSM interface class providing the API. The client runs in a separate thread, which is started by <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/clientIF.py#L319">start()</a> method.</p>

<p>Which method it is to start the VM, you ask? It is the <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/clientIF.py#L451">createVM</a> method called through the <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L161">API create</a>, but there is more to it. Let me walk you through the whole process, it is actually quite interesting how much work is needed to run one VM.</p>

<p>The whole action start with checking if <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L170">VM already exists</a>, we do not want multiple identical VMs running. Next is time for checking whether <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L174">VM was hibernated</a>; if so, load stored machine and update its parameters accordingly. Following is <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L197">parameter validation</a>. This checks required options and fails if they are not present. Next <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L199">parameter fix</a> is in place, this simply fills missing optional parameters by defaults. Fix is followed by <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/API.py#L201">check for supported</a> graphics display. After these checks, <a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/clientIF.py#L451">the clientIF method createVM</a> is called.</p>

<p><a href="https://github.com/oVirt/vdsm/blob/2e1c061429bee3fd829cd71ba0d6e7e088ec5406/lib/vdsm/clientIF.py#L451">CreateVM</a> is actually quite simple method, it creates new VM, adds it to the dictionary and runs it. The VM class is where most of the magic happens. <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2307">VM run</a> method executes in a separate thread, thus it is non-blocking and can pass control to other thread while doing I/O.</p>

<p>The run starts with <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2313">creating VM devices</a> (network, graphics, etc.) and if the VM is not <a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2322">recovering</a> setting them up. Following there are four options for starting the VM, depending on the previous state of the VM.</p>

<ol>
  <li><a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2325">Recover from failure</a>
 This means, the libVirt connection already exists, but something failed. So repair it and run VM again.</li>
  <li><a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2337">Start after migration</a>
 This one is tricky, since at this point the code does nothing. It waits for the migration from one host to other to finish and than disconnects the point of origin, so that only one VM of that kind is running.</li>
  <li><a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2339">Start from file, aka resume from hibernation</a>
 This does what it says, it load the VM from file, apply hooks before starting it. Than it starts the VM by passing the configuration via connection to libVirt. There is one catch, the difference between transient and persistent VM. They start little bit different and for clear and thorough explanation I suggest reading the <a href="https://wiki.libvirt.org/page/VM_lifecycle">libVirt documentation</a>.</li>
  <li><a href="https://github.com/oVirt/vdsm/blob/c1147c232485f51ef972203f1a214439dd38a805/lib/vdsm/virt/vm.py#L2375">Fresh start</a>
 No previous VM exists, so it needs to be created, setup and run. As with resume from hibernation, the custom hooks are applied before starting it and. Than it is created and passed via connection to libVirt. Again, persistent VMs are started little bit different as mentioned.</li>
</ol>

<p>It is worth noting that, the libVirt connection accepts the <a href="https://libvirt.org/formatdomain.html">libVirt XML format</a> as its VM configuration, which was translated from engine configuration to the XML format in createVM phase.</p>

<p>Finally once the libVirt has the XML, it handles the rest and notify back on any change.</p>
 ]]></content>
</entry>



</feed>
